#!/usr/bin/python
"""\
Splitter Backup System of Doom
(c) 2006 Michael D. Labriola <mdlabriola@yahoo.com>

The Splitter Backup System is designed to prepare TAR archives to be burned to
DVD media.  Currently, the maximum file size of an ISO9660 file system is
exactly 2G (2^31 bytes).  Splitter will traverse it's provided list of file
system nodes, creating TAR files no bigger than this limit.  Then you can
simply collect however many of these TAR files fit on your media (DVDs are
around 4.5G and DVD-dl are around 8.2G) into an ISO file using 'mkisofs' and
burn away.

Usage: splitter [MODE] [OPTION]...

Examples:
  splitter -r
  splitter -l
  splitter -l 1
  splitter -c 1
  splitter -c --wait=2
"""


import os
import os.path
import string
import getopt


SPLITTER_VER = "0.7.0"
SIZE_LIMIT = 2**31

NODE_LIST = ["/scrap", "/home"]



def usage(message=None):
    """usage(message)
    displays the usage message along with an error (if one is provided).
    """
    if message:
        print "error: %s" % (message)
    print __doc__


def getsize(node):
    """getsize(node)
    returns the size in bytes of the provided fs node.  this version of getsize
    ignores symlinks and is recursive
    """
    #print "getsize(node=%s)" % (node)
    if os.path.islink(node):
        #print "** link **"
        return 0
    elif os.path.isdir(node):
        #print "** dir **"
        retval = 0
        for x in os.listdir(node):
            retval += getsize(os.path.join(node, x))
        retval += os.path.getsize(node)
        return retval
    else:
        #print "** file **"
        return os.path.getsize(node)


def translate_size(bytes):
    """translate_size(bytes)
    returns human readable size (e.g., 1K, 234M, 2G)
    """
    factor_list = ["", "K", "M", "G", "T"]
    f = 0
    base = bytes
    #print "%d bytes" % bytes
    while base >= 2**10 and f < len(factor_list) - 1:
        base = base / 2**10
        f += 1
    if f > 0:
        rem = bytes % (2**10)**f
        #print "%d%s, %d bytes" % (base, factor_list[f], rem)
        rem_percent = float(rem) / (2**10)**f
        #print "%d is %f%% of 1%s" % (rem, rem_percent, factor_list[f])
        retval = "%.1f%s" % (base + rem_percent, factor_list[f])
    else:
        #print "%d bytes" % base
        retval = "%d" % base
    return retval



class archive:
    """archive
    data type used by archive_list
    """
    def __init__(self):
        self.files = []
        self.size = 0
    
    
    def __str__(self):
        return "archive, %d files, %s" % (len(self.files),
                                          translate_size(self.size))
    
    
    def info(self):
        retval = []
        retval.append("--- archive ---")
        retval.append("files: %s" % self.files)
        retval.append("size: %s" % translate_size(self.size))
        retval.append("---------------")
        return string.join(retval, "\n")
        


class archive_list:
    """archive_list
    this class creates a list of archives no bigger than 'maxsize' from the
    provided 'node_list'.
    """
    def __init__(self, node_list, maxsize):
        self.node_list = node_list
        self.maxsize = maxsize
        self.list = [archive()]
        for x in node_list:
            self.splitter(x)
    
    
    def __str__(self):
        retval = []
        retval.append("----- archive_list -----")
        retval.append("node_list: %s" % self.node_list)
        retval.append("maxsize: %d bytes" % self.maxsize)
        retval.append("archives: %d" % len(self.list))
        for x in self.list:
            retval.append("%s" % x)
            retval[-1] += ", %s remaining" % (translate_size(self.maxsize
                                                             - x.size))
        retval.append("------------------------")
        return string.join(retval, "\n")
    
    
    def splitter(self, node):
        """splitter(node)
        this function traverses the provided filesystem node, adding
        encountered files to the current archive.  when it encounters a file
        that is bigger than 'maxsize', a warning message is displayed and the
        file is ignored.  also, files lacking read permission are ignored with
        a warning.  when it encounters a file that would make the archive
        bigger than 'maxsize', the current archive is finalized and a new
        archive is created.
        """
        #print "splitter(node=%s)" % (node)
        
        # check for read permission
        if not os.access(node, os.R_OK):
            print "WARNING: file not readable: %s" % node
            return
        
        if os.path.islink(node):
            #print "** link **"
            self.list[-1].files.append(node)
            # don't increase size
            return
        elif os.path.isdir(node):
            #print "** dir **"
            for x in os.listdir(node):
                self.splitter(os.path.join(node, x))
        #else:
        #    print "** file **"
        
        s = os.path.getsize(node)
        #print "s: %d" % s
        if s > self.maxsize:
            print "WARNING: file bigger than maxsize: %s" % node
            return
        elif self.list[-1].size + s > self.maxsize:
            self.list.append(archive())
        self.list[-1].files.append(node)
        self.list[-1].size += s



#---------- main program ----------#
print "splitter %s" % SPLITTER_VER

print "node_list: %s" % NODE_LIST
print "size_limit: %s (%d bytes)" % (translate_size(SIZE_LIMIT), SIZE_LIMIT)

x = archive_list(NODE_LIST, SIZE_LIMIT)
print x
